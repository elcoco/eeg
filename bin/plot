#!/usr/bin/python3

try:
    import sys,os

    #from matplotlib import style
    import subprocess

    import inspect
    import re
    from time import strftime
except ImportError as e:
    print('failed to import: {0}'.format(e))
    sys.exit()



class Log(object):
    def __init__(self, logfile=False, level='debug', display=True, maxlength=20):
        self.logfile = logfile
        self.display = display
        self.level = level
        self.maxlength = maxlength

        self.colors = { 'red'    : '\033[31m',
                        'white'  : '\033[37m',
                        'gray'   : '\033[0m',
                        'orange' : '\033[33m',
                        'blue'   : '\033[34m',
                        'green'  : '\033[32m',
                        'reset'  : '\033[0m' }

        self.colors_levels = { 'info'    : 'white',
                               'error'   : 'red',
                               'debug'   : 'gray',
                               'warning' : 'orange' }

        self.custom_highlights = {}


    def choose_show(self, level):
        """ Decide if a message should be shown based on configured message level """
        if self.level == 'error' and (level == 'debug' or level == 'warning' or level == 'info'):
            return False
        if self.level == 'warning' and (level =='debug' or level == 'info'):
            return False
        if self.level == 'info' and (level == 'debug'):
            return False
        return True


    def create_message(self, level, module, message):
        # TODO: Add feature to detect lists/dicts and print them out nicely
        if self.choose_show(level):
            message = self.detect_type(message)
            module_justified = module.ljust(self.maxlength)
            level_justified = level.ljust(7)

            if self.display:
                """
                print("{0} {1}{2}{3}{4} {5} {6} {7}".format(strftime("%H:%M:%S"),
                                                            self.colors[self.colors_levels[level]],
                                                            level_justified.upper(),
                                                            self.colors['reset'],
                                                            module_justified,
                                                            self.colors[self.colors_levels[level]],
                                                            self.custom_highlight(message, self.colors[self.colors_levels[level]]),
                                                            self.colors['reset']))
                """

                print("{0} {1} {2} {3}".format(module_justified,
                                               self.colors[self.colors_levels[level]],
                                               self.custom_highlight(message, self.colors[self.colors_levels[level]]),
                                               self.colors['reset']))

            if self.logfile:
                self.write_to_file("{0} {1}{2}{3}\n".format(strftime("%Y-%m-%d %H:%M:%S"),
                                                            level_justified,
                                                            module_justified,
                                                            message))


    def detect_type(self, message):
        """ Detect whether message is list or dict """
        if type(message) == list:
            message = ' , '.join(message)
        elif type(message) == dict:
            message_out = ''
            for k,v in message.items():
                message_out = "{0}\n{1} : {2}".format(message_out,k,v)
            message = message_out
        return message


    def create_file(self):
        """ Create a file if it doesn't exist """
        try:
            with open(self.logfile) as f: pass
        except IOError as e:
            try:
                FILE = open(self.logfile, 'w')
                FILE.close()
            except IOError as e:
                print('WARNING ... Couldn\'t create file \'%s\' Not writing logs!'%self.logfile)
                return False
        return True


    def write_to_file(self, message):
        if self.create_file():
            try:
                FILE = open(self.logfile, 'a')
                FILE.write(message)
                FILE.close()
            except:
                print('Failed to write to logfile')


    def custom_highlight(self, message, reset_color):
        if message:
            for string, color in self.custom_highlights.items():
                message = re.sub( string, self.colors[color] + string + reset_color, message)
        return message


    def color(self, string, color):
        """ Callable method to add a custom highlight eg. ( log.color('what_to_highlight', 'color_to_use') ) """
        self.custom_highlights[string] = color


    def info(self, message):
        self.create_message('info', inspect.stack()[1][3], message)


    def debug(self, message):
        self.create_message('debug', inspect.stack()[1][3], message)


    def warning(self, message):
        self.create_message('warning', inspect.stack()[1][3], message)


    def error(self, message):
        self.create_message('error', inspect.stack()[1][3], message)


    def red(self, message):
        self.create_message('info', inspect.stack()[1][3], message)


    def blue(self, message):
        self.create_message('info', inspect.stack()[1][3], message)


    def green(self, message):
        self.create_message('info', inspect.stack()[1][3], message)


    def orange(self, message):
        self.create_message('info', inspect.stack()[1][3], message)




class Plot(object):
    def __init__(self):
        pass


    def get_file(self):
        """ Get contents of a file and put every line in a list"""
        contents = []
        try:
            f = open('/home/eco/eeg.txt', 'r')
        except IOError as e:
            if not self.quiet:
                print('No config file found at: {0}'.format(self.config_file_path))
            return False

        for line in f:
            if line:
                contents.append(self.sanitize(line))
        f.close()

        if contents:
            return contents
        return False


    def get_last_lines(self, f, n, offset=0):
        result = []
        try:
            child = subprocess.Popen("tail -n {0} {1}".format(n+offset, f), shell=True, stdout=subprocess.PIPE)
        except:
            log.error('Failed to execute command')
            return False
            
        child.wait()

        while True:
            stdout = child.stdout.readline()
            stdout = stdout.decode()
            stdout = stdout.strip()
            if stdout == '' and child.poll() != None:
                break
            else:
                result.append(stdout)
        return result


    def sanitize(self, data, extra_opts=[]):
        sanitize_list = [' ', '\n'] + extra_opts
        for sanitize in sanitize_list:
            data = data.strip(sanitize)
        return data


    def setup(self):
        self.fig = plt.figure()
        self.fig.autofmt_xdate()
        self.ax1 = self.fig.add_subplot(1,1,1)

        #self.ax1.fmt_ydata = mdates.DateFormatter('%Y-%m-%d %H:%M:%S.%f')

        #seconds = mdates.SecondLocator()
        #self.ax1.set_major_locator(seconds)


    def animate(self, i):
        xs = []
        ys = []

        datas = self.get_file()
        datas = self.get_last_lines('/home/eco/eeg.txt', 100)
        for data in datas:
            print(data)
            data = data.split('|')
            if data[1] == '1':
                ys.append(int(data[2]))
                xs.append(data[0])
                
        #self.ax1.format_xdata = mdates.DateFormatter('%Y-%m-%d %H:%M:%S.%f')
        self.ax1.clear()
        self.ax1.plot(ys)
        plt.draw()


    def run(self):
        self.setup()
        ani = animation.FuncAnimation(self.fig, self.animate, interval=20)
        plt.show()




if __name__ == "__main__":
    log = Log()
    log.color('>>>', 'green')
    log.color('<<<', 'blue')
#    app = Plot()
#    app.run()

log = Log()
log.color('>>>', 'green')
log.color('<<<', 'blue')


def get_last_lines(f, n, offset=0):
    result = []
    try:
        child = subprocess.Popen("tail -n {0} {1}".format(n+offset, f), shell=True, stdout=subprocess.PIPE)
    except:
        log.error('Failed to execute command')
        return False
        
    child.wait()

    while True:
        stdout = child.stdout.readline()
        stdout = stdout.decode()
        stdout = stdout.strip()
        if stdout == '' and child.poll() != None:
            break
        else:
            result.append(stdout)
    return result


import matplotlib
#matplotlib.use('Qt5Agg')
import numpy as np
import matplotlib.pyplot as plt
import time


length = 60
plot_length = 50

# fig is outer box
# axes is plotting area containing all the elements
# axis is the actual axis in the graph (ticks (locator object), formatted by a Formatter
# artists is almost everything that you can see like titles,figure legends, lines text etc.

fig,ax = plt.subplots()
line1, = ax.plot(np.random.randn(plot_length))
line2, = ax.plot(np.random.randn(plot_length)+5)
#line3, = ax.plot(np.random.randn(plot_length)+10)
#line4, = ax.plot(np.random.randn(plot_length)+15)
#line5, = ax.plot(np.random.randn(plot_length)+20)


#ax.set_xlabel('Time')
#ax.set_ylabel('Volts')
#ax.set_title('Graphs for world domination')

#plt.legend()
#plt.xlim([0,1000])
plt.ion()

plt.title('Graphs for world domination')
plt.xlabel('Time')
plt.ylabel('Volts')
plt.grid(True)

plt.show()

fig.canvas.draw()



tstart = time.time()
num_plots = 0

while time.time() - tstart < length:
    line1.set_ydata(np.random.randn(plot_length))
#    line2.set_ydata(np.random.randn(plot_length) +5)
#    line3.set_ydata(np.random.randn(plot_length) +10)
#    line4.set_ydata(np.random.randn(plot_length) +15)
#    line5.set_ydata(np.random.randn(plot_length) +20)

    ax.draw_artist(ax.patch)

    ax.draw_artist(line1)
#    ax.draw_artist(line2)
#    ax.draw_artist(line3)
#    ax.draw_artist(line4)
#    ax.draw_artist(line5)

    fig.canvas.update()
#    fig.canvas.draw()
#    plt.draw()
    fig.canvas.flush_events()
    #plt.show()
    num_plots += 1

print(num_plots/length)





