#!/usr/bin/python3

try:
    import sys,os

#    from matplotlib import style
#    import matplotlib.pyplot as plt
#    import matplotlib.animation as animation
#    import matplotlib.dates as dates
    import pyqtgraph as pg
    from pyqtgraph.Qt import QtCore, QtGui
    import numpy as np


    import threading

    import datetime
    import socket
    import select
    import time

    import inspect
    import re
    from time import strftime
except ImportError as e:
    print('failed to import: {0}'.format(e))
    sys.exit()


class StoppableThread(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.stop_flag = threading.Event()

    def stop(self):
        if self.isAlive() == True:
            self.stop_flag.set()

    def stopped(self):
        return self.stop_flag.is_set()



class Log(object):
    def __init__(self, logfile=False, level='debug', display=True, maxlength=20):
        self.logfile = logfile
        self.display = display
        self.level = level
        self.maxlength = maxlength

        self.colors = { 'red'    : '\033[31m',
                        'white'  : '\033[37m',
                        'gray'   : '\033[0m',
                        'orange' : '\033[33m',
                        'blue'   : '\033[34m',
                        'green'  : '\033[32m',
                        'reset'  : '\033[0m' }

        self.colors_levels = { 'info'    : 'white',
                               'error'   : 'red',
                               'debug'   : 'gray',
                               'warning' : 'orange' }

        self.custom_highlights = {}


    def choose_show(self, level):
        """ Decide if a message should be shown based on configured message level """
        if self.level == 'error' and (level == 'debug' or level == 'warning' or level == 'info'):
            return False
        if self.level == 'warning' and (level =='debug' or level == 'info'):
            return False
        if self.level == 'info' and (level == 'debug'):
            return False
        return True


    def create_message(self, level, module, message):
        # TODO: Add feature to detect lists/dicts and print them out nicely
        if self.choose_show(level):
            message = self.detect_type(message)
            module_justified = module.ljust(self.maxlength)
            level_justified = level.ljust(7)

            if self.display:
                """
                print("{0} {1}{2}{3}{4} {5} {6} {7}".format(strftime("%H:%M:%S"),
                                                            self.colors[self.colors_levels[level]],
                                                            level_justified.upper(),
                                                            self.colors['reset'],
                                                            module_justified,
                                                            self.colors[self.colors_levels[level]],
                                                            self.custom_highlight(message, self.colors[self.colors_levels[level]]),
                                                            self.colors['reset']))
                """

                print("{0} {1} {2} {3}".format(module_justified,
                                               self.colors[self.colors_levels[level]],
                                               self.custom_highlight(message, self.colors[self.colors_levels[level]]),
                                               self.colors['reset']))

            if self.logfile:
                self.write_to_file("{0} {1}{2}{3}\n".format(strftime("%Y-%m-%d %H:%M:%S"),
                                                            level_justified,
                                                            module_justified,
                                                            message))


    def detect_type(self, message):
        """ Detect whether message is list or dict """
        if type(message) == list:
            message = ' , '.join(message)
        elif type(message) == dict:
            message_out = ''
            for k,v in message.items():
                message_out = "{0}\n{1} : {2}".format(message_out,k,v)
            message = message_out
        return message


    def create_file(self):
        """ Create a file if it doesn't exist """
        try:
            with open(self.logfile) as f: pass
        except IOError as e:
            try:
                FILE = open(self.logfile, 'w')
                FILE.close()
            except IOError as e:
                print('WARNING ... Couldn\'t create file \'%s\' Not writing logs!'%self.logfile)
                return False
        return True


    def write_to_file(self, message):
        if self.create_file():
            try:
                FILE = open(self.logfile, 'a')
                FILE.write(message)
                FILE.close()
            except:
                print('Failed to write to logfile')


    def custom_highlight(self, message, reset_color):
        if message:
            for string, color in self.custom_highlights.items():
                message = re.sub( string, self.colors[color] + string + reset_color, message)
        return message


    def color(self, string, color):
        """ Callable method to add a custom highlight eg. ( log.color('what_to_highlight', 'color_to_use') ) """
        self.custom_highlights[string] = color


    def info(self, message):
        self.create_message('info', inspect.stack()[1][3], message)


    def debug(self, message):
        self.create_message('debug', inspect.stack()[1][3], message)


    def warning(self, message):
        self.create_message('warning', inspect.stack()[1][3], message)


    def error(self, message):
        self.create_message('error', inspect.stack()[1][3], message)


    def red(self, message):
        self.create_message('info', inspect.stack()[1][3], message)


    def blue(self, message):
        self.create_message('info', inspect.stack()[1][3], message)


    def green(self, message):
        self.create_message('info', inspect.stack()[1][3], message)


    def orange(self, message):
        self.create_message('info', inspect.stack()[1][3], message)



class Config_Option(object):
    """ Helper class of Config() """
    def __init__(self, section=False, comment=[], key=False, value=False):
        self.section = section
        self.key = key
        self.value = value
        if comment:
            if type(comment) == list:
                self.comment = comment
            else:
                self.comment = [comment]
        else:
            self.comment = []

    def set_comment(self, comment): 
        if type(comment) == list:
            self.comment = comment
        else:
            self.comment = [comment]

    def set_section(self, section): self.section = section
    def set_key(self, key): self.key = value
    def set_value(self, value): self.value = value
    def get_section(self): return self.section
    def get_comment(self): return self.comment
    def get_key(self): return self.key
    def get_value(self): return self.value



class Config(object):
    def __init__(self, quiet=False):
        self.config_file_path = False
        # This list stores all config option objects
        self.config = []
        # display errrors
        self.quiet = quiet


    def set_option(self, option): self.config.append(option)
    def set_config_path(self, path): self.config_file_path = path
    def get_options(self): return sorted(self.config, key=lambda x: x.get_section(), reverse=False)
    def get_config_path(self): return self.config_file_path


    def test_float(self, var):
        try:
            return float(var)
        except:
            return False


    def test_int(self, var):
        try:
            return int(var)
        except:
            return False


    def convert_numbers(self, var):
        """ Convert strings or lists of numbers to floats or ints """
        # var is a list
        if type(var) == list:

            for x in range(0, len(var)):
                if self.test_int(var[x]):
                    var[x] = self.test_int(var[x])
                elif self.test_float(var[x]):
                    var[x] = self.test_float(var[x])

        # Var is not a list
        else:
            if self.test_int(var):
                var = int(var)
            elif self.test_float(var):
                var = float(var)

        return var


    def parse_file(self, path):
        """ Parse file and create a list with option objects """

        # Get config file contents in a list
        section = False
        comments = []

        config_file = self.get_file()

        if not config_file:
            return False

        for line in config_file:
            # clean line from whitespaces, newlines etc
            line = self.sanitize(line)

            # Line is empty, do nothing
            if not line:
                pass

            # Line is commented
            elif line[0] == '#':
                comments.append(self.sanitize(line[1:]))

            # Line is a section header
            elif line[0] == '[' and line[-1] == ']':
                section = self.sanitize(line, extra_opts = ['[', ']'])

            # We are in a section loop
            elif section:

                # Line is a key/value pair
                if '=' in line:
                    k,v = line.split('=', 1)
                    k = self.sanitize(k)
                    v = self.sanitize(v)

                    # replace certain values like ~ -> /home/<user>
                    v = self.replace(v)
                    # TODO Find a solution for this, the replaced variable should not be written back to the file
                    #      Also does this not work for variables set by config.set()

                    # Value is empty, add empty value
                    if not v:
                        option = self.set(section, k, '', comment=comments)
                        comments = []


                    # Value is a list
                    elif v[0] == '[' and v[-1] == ']':
                        v = self.sanitize(v, extra_opts = ['[', ']'])

                        # Value contains a comma. read all values in a list
                        if ',' in v:
                            v_list = self.sanitize_list(v.split(','))
                            option = self.set(section, k, v_list, comment=comments)
                            comments = []


                        # Value doesn't contain comma so could be a list with a single item or an empty list
                        else:
                            if v:
                                option = self.set(section, k, v, comment=comments)
                            else:
                                option = self.set(section, k, [], comment=comments)
                            comments = []

                    # Value is a simple key, value pair
                    else:
                        option = self.set(section, k, v, comment=comments)
                        comments = []

        return self.config


    def set(self, section, k, v, comment=[]):
        """ Create a config_option() instance and fill it with data """
        v = self.convert_numbers(v)
        # If option already exist, change it
        for option in self.get_options():
            if option.get_section() == section:
                if option.get_key() == k:
                    option.set_comment(comment)
                    option.set_value(v)
                    return option
        # If option does not exist, create it
        option = Config_Option(key=k, value=v, section=section, comment=comment)
        self.set_option(option)
        return option


    def get(self, section, key):
        """ Get a value from list of config_option() instances in self.config by section and key """
        for option in self.get_options():
            if option.get_section() == section:
                if option.get_key() == key:
                    return option.get_value()
        if not self.quiet:
            print('Couldn\'t find value for key in section {0} : {1}'.format(section, key))
        return False


    def test_file(self):
        """ Test if file exists """
        try:
            with open(self.config_file_path) as f: pass
            return True
        except IOError as e:
            return False


    def ensure_dir(self, dirname):
        if not os.path.exists(dirname):
            os.makedirs(dirname)


    def write_to_file(self, data=False, remove=False):
        """ Write a string to a file, remove file if it exists by giving remove=False """
        if not self.get_config_path():
            return False

        self.ensure_dir(os.path.dirname(self.get_config_path()))

        if remove == True:
            try:
                FILE = open(self.config_file_path, 'w')
                FILE.close()
                return True
            except:
                if not self.quiet:
                    print('Failed to remove file')
                return False

        else:
            try:
                FILE = open(self.config_file_path, 'a')
                FILE.write(data + '\n')
                FILE.close()
                return True
            except:
                if not self.quiet:
                    print('Failed to write to file')
                pass
        return False


    def write(self):
        """ Write the config to disk """

        self.write_to_file(remove=True)
        section = False
        first = True

        for option in self.get_options():
            current_section = option.get_section()

            if not current_section == section:
                # Only put newline above section header if it is not the first one
                if first:
                    self.write_to_file('[{0}]'.format(current_section))
                    first = False
                else:
                    self.write_to_file('\n[{0}]'.format(current_section))
                section = current_section

            comment = option.get_comment()
            for c in comment:
                self.write_to_file('# {0}'.format(c))

            value = option.get_value()
            if type(value) == list:
                value = '[{0}]'.format(','.join(value))

            self.write_to_file('{0} = {1}'.format(option.get_key(),value))
        if not self.quiet:
            print('File written to: {0}'.format(self.config_file_path))


    def get_file(self):
        """ Get contents of a file and put every line in a list"""
        contents = []
        try:
            f = open(self.config_file_path, 'r')
        except IOError as e:
            if not self.quiet:
                print('No config file found at: {0}'.format(self.config_file_path))
            return False

        for line in f:
            if line:
                contents.append(self.sanitize(line))
        f.close()

        if contents:
            return contents
        return False


    def sanitize(self, data, extra_opts = []):
        """ Clean variable from newlines, leading/trailing spaces and other stuff """
        sanitize_list = [' ', '\'', '\"', '\n'] + extra_opts
        for sanitize in sanitize_list:
            data = data.strip(sanitize)
        return data


    def sanitize_list(self, data):
        """ Clean list indices from newlines, leading/trailing spaces and other stuff """
        output = []
        for x in data:
            x = x.strip()
            x = x.strip('\'')
            x = x.strip('\"')
            x = x.strip('\n')
            x = x.strip('[')
            x = x.strip(']')
            output.append(x)
        data = output[:]
        return data


    def replace(self, data):
        """ Replace characters or strings in a string with something else """
        replace_list = {'~' : os.getenv("HOME"), '<HOSTNAME>' : socket.gethostname()}
        for k,v in replace_list.items():
            data = data.replace(k, v)
        return data


    def parse(self):
        # Parse the config file
        if self.parse_file(self.config_file_path):
            return True
        return False



class Data(object):
    def __init__(self):
        # TODO: create a method to create a filename with date_increasing number
        self.channel = False
        self.data = False
        self.loff_p = True
        self.loff_n = True
        #self.timestamp = datetime.datetime.now().strftime("%H:%M:%S.%f")
        self.timestamp = datetime.datetime.today()


    def set_channel(self, channel): self.channel = channel
    def set_data(self, data): self.data = data
    def set_loff_n(self, state): self.loff_n = state
    def set_loff_p(self, state): self.loff_p = state
    def get_channel(self): return self.channel
    def get_data(self): return self.data
    def get_timestamp(self): return self.timestamp
    def get_loff_p(self): return self.loff_p
    def get_loff_n(self): return self.loff_n


    def create_file(self):
        """ Create a file if it doesn't exist """
        try:
            with open(config.get('log', 'path')) as f: pass
        except IOError as e:
            try:
                FILE = open(config.get('log', 'path'), 'w')
                FILE.close()
            except IOError as e:
                log.error('WARNING ... Couldn\'t create file \'%s\''%self.write_path)
                return False
        return True


    def write(self):
        """ Write data to file """
        if self.create_file():
            try:
                FILE = open(config.get('log', 'path'), 'a')
                #FILE.write("{0}|{1}|{2}\n".format(self.get_timestamp(), \
                #                                  self.get_channel(), \
                #                                  self.get_data()))
                FILE.write("{0}|{1}\n".format( self.get_channel(), \
                                                  self.get_data()))
                FILE.close()
            except:
                log.error('Failed to write to file')


    def display(self):
        log.info("{0} {1} {2}".format(self.get_timestamp(), self.get_channel(), self.get_data()))



class DataList(object):
    def __init__(self):
        self.data = []


    def add_data(self, data): self.data.append(data)


    def get_last_items(self, channel, last_item=False, amount=False):
        # Get the newest items since the last_item object
        
        # Make a copy to work with, there could occur changes while running this method
        data_list = self.get_data_list(channel)[:]

        # When first run, return all the data received so far
        if not last_item:
            return data_list

        return_list = []

        # Reverse cycle through list_date, searching for last_item and adding all the
        # found objects to return_list on the way
        for data in reversed(data_list):
            if data == last_item:
                return list(reversed(return_list))

            return_list.append(data)

        log.error('Could not find last_item: {0}'.format(last_item))
        return False


    def get_data_list(self, channel):
        return_list = []
        data_tmp = self.data[:]
        for data in data_tmp:
            if int(data.get_channel()) == int(channel):
                return_list.append(data)

        return return_list


class Socket(object):
    def __init__(self, host, port):
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            log.info('Client socket created')
        except socket.error:
            log.error('Failed to create client socket')
            sys.exit()
        #self.socket = socket.socket()
        #self.socket.settimeout(20)
        try:
            self.socket.connect((host, port))
            log.info('Connected to server')
        except socket.error:
            log.error('Failed to connect to server')
            sys.exit()


    def send(self, data, prefix=False):
        # TODO check if connection is still alive
        if prefix:
            data = str(len(data)).rjust(3, '0') + data

        data_bytes = data.encode()

        try:
            self.socket.sendall(data_bytes)
            log.info('>>> {0}'.format(data))
            return True
        except:
            log.error('Failed to send data')
            return False


    def receive(self, bits):
        # TODO check if connection is still alive
        try:
            data = self.socket.recv(int(bits)).decode('utf-8')
            return self.sanitize(data)
        except:
            log.error('Failed to receive data')
        return False


    def sanitize(self, data):
        data = data.strip('\n')
        return data



class PlotThread(StoppableThread):
    def __init__(self):
        StoppableThread.__init__(self)


    def setup(self):
        self.fig = plt.figure()
        self.ax1 = self.fig.add_subplot(1,1,1)


    def animate(self):
        xar = []
        yar = []

        for data in datalist.get_data_list():
            xar.append(data.get_data())
            yar.append(data.get_timestamp())
        self.ax1.clear()
        self.ax1.plot(xar,yar)


    def plot(self):
        self.setup()
        ani = animation.FuncAnimation(self.fig, self.animate, interval=1000)
        plt.show()
        print('lkjj')


    def run(self):
        print('lkjj')
        self.plot()
        while True:
            pass



class QtThread(StoppableThread):

    def __init__(self):
        StoppableThread.__init__(self)


    def get_timestamp(self):
        return datetime.datetime.today()



    def setup(self):
        # Must be set before creating any widgets
        pg.setConfigOption('background', 0.1)

        # Create a grid with multiple items
        self.win = pg.GraphicsWindow()
        self.win.setWindowTitle('EEG')

        # Vars to keep track of frames and location of frames
        self.plots = []
        self.curves = []
        self.data_buffers = []        # Stores numpy data arrays containing the full data list
        self.framecount = {}          # Stores the number of frames so we can check if it fits in the buffer
        self.total_framecount = 0     # Stores the total number of frames for all channels combined to calculate FPS
        self.last_frames = {}         # last_frames is the  dict that stores the last fetched frame by channel
        self.start_time = False       # For FPS calculation
        self.running = False          # Make sure only one verion of update() is running
        self.total_fps = 0              # Keep track of FPS

        bar_size = 1000
        self.n_plots = 8

        # Setup plots and curves fill their contents with empty numpy arrays
        for i in range(0, self.n_plots):
            p = self.win.addPlot(row=i,col=1)
            p.setRange(xRange=[-bar_size, 0])
            p.setLimits(xMax=0)
            p.setClipToView(True)
            p.setDownsampling(mode='peak')

            curve = p.plot(pen=i)
            data = np.empty(bar_size)

            self.plots.append(p)
            self.curves.append(curve)
            self.data_buffers.append(data)
            self.framecount[i] = 0




    def update_channel(self, channel, new_frames):
        """
        Create empty buffer as large as ROI (region of interest)
        count = count the frames that we collect

        if countofframes + new frames >= buffer size
            backup the last list + new data
            create new buffer which is bigger
            copy old list back to new buffer
        """

        # lists start with zero
        channel = channel - 1

        # Short names are good!
        framecount = self.framecount[channel]
        data_buffer = self.data_buffers[channel]
        curve = self.curves[channel]

        # Combine the old buffer and the new data
        data_buffer = np.append(data_buffer, new_frames)

        # update the framecount with the new data (numpy array length is fetched with data.shape[0]
        framecount += new_frames.shape[0]

        # If the length of data is bigger than the buffer, we have to enlarge the buffer
        if framecount >= data_buffer.shape[0]:
            log.info('>>> we have to enlarge buffer: {0} >= {1}'.format(framecount, data_buffer.shape[0]))

            # Backup old bufer
            tmp = data_buffer
            
            # Create new buffer, double the size of the old one
            data_buffer = np.empty(data_buffer.shape[0] * 2)

            # Copy the buffer back to the first half of the new, bigger buffer
            data_buffer[:tmp.shape[0]] = tmp

        # Update pyqtgraph with the first half (new) of the buffer
        curve.setData(data_buffer[:framecount])
        curve.setPos(-framecount, 0)
        #self.plots[channel].setTitle('Channel {0} - FPS {1}'.format(channel, self.total_fps))

        self.framecount[channel] = framecount
        self.data_buffers[channel] = data_buffer
        self.curves[channel] = curve
        #self.total_framecount += framecount


    def update(self):
        # Make sure only one version of this method is running
        if self.running: return
        self.running = True

        self.total_framecount = 0

        for channel in range(1, self.n_plots+1):
            if config.get('channel' + str(channel), 'state') == 'on':

                # Set default values for last_items
                # last_frames is the  dict that stores the last fetched frame by channel
                if channel not in self.last_frames.keys():
                    self.last_frames[channel] = False

                # Retrieve list of objects newer than last_item (which is the Data() object that was last)
                datas = datalist.get_last_items(channel, self.last_frames[channel])

                if datas:
                    # For FPS calculation
                    self.total_framecount += len(datas)

                    # remove first lot of frames if it is the first go, this should be changed obviously
                    if not self.last_frames[channel]:
                        datas = datas[-1:]

                    # Set last received frame in self.last_frames
                    self.last_frames[channel] = datas[-1]

                    log.info('>>> {0}: {1} Frames'.format(channel, str(len(datas))))

                    data_chunk = []
                    for data in datas:
                        data_chunk.append(int(data.get_data()))

                    # Update the graph with the new data, provide -> channel, chunk of data, last state, current state
                    self.update_channel( channel, np.array(data_chunk))

        # Calculate total FPS
        if self.start_time:
            self.total_fps = self.total_framecount / (self.get_timestamp() - self.start_time).total_seconds()
        self.start_time = self.get_timestamp()
        self.plots[0].setTitle('FPS {0}'.format(self.total_fps))
        self.running = False


    def run(self):
        self.setup()

        timer = pg.QtCore.QTimer()
        timer.timeout.connect(self.update)
        timer.start(200)

        QtGui.QApplication.instance().exec_()











class EEG(object):
    def get_file(self, filename):
        """ Get contents of a file and put every line in a list"""
        contents = []
        try:
            f = open(filename, 'r')
        except IOError as e:
            log.error('No config file found at: {0}'.format(filename))
            return False

        for line in f:
            if line:
                contents.append(line)
        f.close()

        if contents:
            return contents
        return False


    def start_threads(self):
        self.running_threads = []
        self.running_threads.append(QtThread().start())


    def stop_threads(self):
        for thread in self.running_threads:
            thread.stop()


    def get_data(self):
        start_time = self.get_timestamp()
        total_frames = 0

        while True:
            # Receive length of data first
            length = self.socket.receive(config.get('general', 'length-size'))
            if length:
                # then get the full frame 
                data = self.socket.receive(length)
                if data:
                    self.add_data(data)
                    total_frames += 1
            else:
                log.error('Error getting data')
                return False

            # If run-time has reached, send the STOP command to the server
            if start_time + int(config.get('general', 'run-time')) <= self.get_timestamp():
                log.info('Run time reached')
                self.socket.send('STOP', prefix=True)

                log.info("Total frames: {0}".format(total_frames))
                log.info("Total time (s): {0}".format(self.get_timestamp() - start_time))
                log.info("FPS: {0}".format(total_frames / (self.get_timestamp() - start_time)))
                # TODO: receive total frames sent from server and calculate dropped packages
                # TODO: Packet timing is important since we want to do spectrum analysis
                return True

        log.error('An error occured while transfer')
        return False


    def get_timestamp(self):
        return int(strftime("%d%H%M%S"))


    def add_data(self, rd):
        # Create data objects and add to datalist object
        rd = rd.split(',')

        channel = 0
        for index in range(3, len(rd)):
            # TODO find the status bit for loff-n and loff-p
            channel += 1
            if config.get('channel'+ str(channel), 'state') == 'on':
                data = Data()
                data.set_channel(channel)
                data.set_data(rd[index])
                #data.write()   # Should be done in a thread otherwise -> dropped frames
                #data.display()
                datalist.add_data(data)


    def send_channel_config(self):
        for channel in range(1, 8+1):
            state = config.get('channel' + str(channel), 'state')
            if state == "on":
                self.socket.send('CHNSET,{0},1'.format(channel), prefix=True)
            else:
                self.socket.send('CHNSET,{0},0'.format(channel), prefix=True)


    def set_channel_config(self, channels):
        channels = channels.split(',')
        channels = [ int(x) for x in channels ]

        for channel in range(1, 8+1):
            if channel in channels:
                config.set('channel' + str(channel), 'state', 'on')
            else:
                config.set('channel' + str(channel), 'state', 'off')


    def usage(self):
        print("PYEEG")
        print("OPTIONS:")
        print("  --noise-check")
        print("  --test-signal")
        print("  --shutdown")


    def set_config_defaults(self):
        config.set('server', 'address', 'alarmpi')
        config.set('server', 'port', '8888')
        config.set('general', 'length-size', '3')
        config.set('general', 'run-time', '60')
        config.set('channel1', 'state', 'on')
        config.set('channel2', 'state', 'on')
        config.set('channel3', 'state', 'on')
        config.set('channel4', 'state', 'on')
        config.set('channel5', 'state', 'on')
        config.set('channel6', 'state', 'on')
        config.set('channel7', 'state', 'on')
        config.set('channel8', 'state', 'on')
        config.set('log', 'path', '/home/eco/eeg.txt')


    def handle_arg(self):
        if len(sys.argv) < 2 or "--help" in sys.argv:
            return self.usage()

        # Setting config values
        for arg in sys.argv:

            if len(arg.split('=')) == 2:
                key = arg.split('=')[0][2:]
                value = arg.split('=')[1]

                if '--run-time=' in arg:
                    config.set('general', key, value)

                elif '--address=' in arg:
                    config.set('server', key, value)

                elif '--port=' in arg:
                    config.set('server', key, value)

                elif '--channels=' in arg:
                    self.set_channel_config(value)


        # Commands
        for arg in sys.argv:
            if "--plot" in arg:
                self.start_threads()

            if "--start" in arg:
                # NOTE is not receiving on the c side!!
                self.send_channel_config()
                self.socket.send('START', prefix=True)
                self.get_data()

            elif "--noise-check" in arg:
                self.socket.send('NOISECHECK', prefix=True)
                self.get_data()

            elif "--test-signal" in arg:
                self.socket.send('TESTSIGNAL', prefix=True)
                self.get_data()

            elif "--shutdown" in arg:
                self.socket.send('SHUTDOWN', prefix=True)

        return False


    def run(self):
        #self.start_threads()
        self.set_config_defaults()
        # Should go in a thread
        #self.setup_plot()
        #self.plot()

        # Create socket
        self.socket = Socket(config.get('server', 'address'), config.get('server', 'port'))

        #self.plot() 
        self.handle_arg()

        # NOTE Live updating plot

""" 
Create a method get_last_n(last_item, amount)
retrieve the newest entries since last_item

thread for qt app checkt get_last_n() for new entries
""" 



if __name__ == "__main__":
    config = Config()
    datalist = DataList()
    log = Log()
    log.color('>>>', 'green')
    log.color('<<<', 'blue')
    log.color('###', 'red')
    log.color('---', 'blue')

    app = EEG()
    app.run()
