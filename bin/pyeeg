#!/usr/bin/python3

try:
    import sys,os
    from matplotlib import style

    import threading

    import datetime
    import socket
    import select

    import inspect
    import re
    from time import strftime
except ImportError as e:
    print('failed to import: {0}'.format(e))
    sys.exit()


class StoppableThread(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.stop_flag = threading.Event()

    def stop(self):
        if self.isAlive() == True:
            self.stop_flag.set()

    def stopped(self):
        return self.stop_flag.is_set()



class Log(object):
    def __init__(self, logfile=False, level='debug', display=True, maxlength=20):
        self.logfile = logfile
        self.display = display
        self.level = level
        self.maxlength = maxlength

        self.colors = { 'red'    : '\033[31m',
                        'white'  : '\033[37m',
                        'gray'   : '\033[0m',
                        'orange' : '\033[33m',
                        'blue'   : '\033[34m',
                        'green'  : '\033[32m',
                        'reset'  : '\033[0m' }

        self.colors_levels = { 'info'    : 'white',
                               'error'   : 'red',
                               'debug'   : 'gray',
                               'warning' : 'orange' }

        self.custom_highlights = {}


    def choose_show(self, level):
        """ Decide if a message should be shown based on configured message level """
        if self.level == 'error' and (level == 'debug' or level == 'warning' or level == 'info'):
            return False
        if self.level == 'warning' and (level =='debug' or level == 'info'):
            return False
        if self.level == 'info' and (level == 'debug'):
            return False
        return True


    def create_message(self, level, module, message):
        # TODO: Add feature to detect lists/dicts and print them out nicely
        if self.choose_show(level):
            message = self.detect_type(message)
            module_justified = module.ljust(self.maxlength)
            level_justified = level.ljust(7)

            if self.display:
                """
                print("{0} {1}{2}{3}{4} {5} {6} {7}".format(strftime("%H:%M:%S"),
                                                            self.colors[self.colors_levels[level]],
                                                            level_justified.upper(),
                                                            self.colors['reset'],
                                                            module_justified,
                                                            self.colors[self.colors_levels[level]],
                                                            self.custom_highlight(message, self.colors[self.colors_levels[level]]),
                                                            self.colors['reset']))
                """

                print("{0} {1} {2} {3}".format(module_justified,
                                               self.colors[self.colors_levels[level]],
                                               self.custom_highlight(message, self.colors[self.colors_levels[level]]),
                                               self.colors['reset']))

            if self.logfile:
                self.write_to_file("{0} {1}{2}{3}\n".format(strftime("%Y-%m-%d %H:%M:%S"),
                                                            level_justified,
                                                            module_justified,
                                                            message))


    def detect_type(self, message):
        """ Detect whether message is list or dict """
        if type(message) == list:
            message = ' , '.join(message)
        elif type(message) == dict:
            message_out = ''
            for k,v in message.items():
                message_out = "{0}\n{1} : {2}".format(message_out,k,v)
            message = message_out
        return message


    def create_file(self):
        """ Create a file if it doesn't exist """
        try:
            with open(self.logfile) as f: pass
        except IOError as e:
            try:
                FILE = open(self.logfile, 'w')
                FILE.close()
            except IOError as e:
                print('WARNING ... Couldn\'t create file \'%s\' Not writing logs!'%self.logfile)
                return False
        return True


    def write_to_file(self, message):
        if self.create_file():
            try:
                FILE = open(self.logfile, 'a')
                FILE.write(message)
                FILE.close()
            except:
                print('Failed to write to logfile')


    def custom_highlight(self, message, reset_color):
        if message:
            for string, color in self.custom_highlights.items():
                message = re.sub( string, self.colors[color] + string + reset_color, message)
        return message


    def color(self, string, color):
        """ Callable method to add a custom highlight eg. ( log.color('what_to_highlight', 'color_to_use') ) """
        self.custom_highlights[string] = color


    def info(self, message):
        self.create_message('info', inspect.stack()[1][3], message)


    def debug(self, message):
        self.create_message('debug', inspect.stack()[1][3], message)


    def warning(self, message):
        self.create_message('warning', inspect.stack()[1][3], message)


    def error(self, message):
        self.create_message('error', inspect.stack()[1][3], message)


    def red(self, message):
        self.create_message('info', inspect.stack()[1][3], message)


    def blue(self, message):
        self.create_message('info', inspect.stack()[1][3], message)


    def green(self, message):
        self.create_message('info', inspect.stack()[1][3], message)


    def orange(self, message):
        self.create_message('info', inspect.stack()[1][3], message)



class Config_Option(object):
    """ Helper class of Config() """
    def __init__(self, section=False, comment=[], key=False, value=False):
        self.section = section
        self.key = key
        self.value = value
        if comment:
            if type(comment) == list:
                self.comment = comment
            else:
                self.comment = [comment]
        else:
            self.comment = []

    def set_comment(self, comment): 
        if type(comment) == list:
            self.comment = comment
        else:
            self.comment = [comment]

    def set_section(self, section): self.section = section
    def set_key(self, key): self.key = value
    def set_value(self, value): self.value = value
    def get_section(self): return self.section
    def get_comment(self): return self.comment
    def get_key(self): return self.key
    def get_value(self): return self.value



class Config(object):
    def __init__(self, quiet=False):
        self.config_file_path = False
        # This list stores all config option objects
        self.config = []
        # display errrors
        self.quiet = quiet


    def set_option(self, option): self.config.append(option)
    def set_config_path(self, path): self.config_file_path = path
    def get_options(self): return sorted(self.config, key=lambda x: x.get_section(), reverse=False)
    def get_config_path(self): return self.config_file_path


    def test_float(self, var):
        try:
            return float(var)
        except:
            return False


    def test_int(self, var):
        try:
            return int(var)
        except:
            return False


    def convert_numbers(self, var):
        """ Convert strings or lists of numbers to floats or ints """
        # var is a list
        if type(var) == list:

            for x in range(0, len(var)):
                if self.test_int(var[x]):
                    var[x] = self.test_int(var[x])
                elif self.test_float(var[x]):
                    var[x] = self.test_float(var[x])

        # Var is not a list
        else:
            if self.test_int(var):
                var = int(var)
            elif self.test_float(var):
                var = float(var)

        return var


    def parse_file(self, path):
        """ Parse file and create a list with option objects """

        # Get config file contents in a list
        section = False
        comments = []

        config_file = self.get_file()

        if not config_file:
            return False

        for line in config_file:
            # clean line from whitespaces, newlines etc
            line = self.sanitize(line)

            # Line is empty, do nothing
            if not line:
                pass

            # Line is commented
            elif line[0] == '#':
                comments.append(self.sanitize(line[1:]))

            # Line is a section header
            elif line[0] == '[' and line[-1] == ']':
                section = self.sanitize(line, extra_opts = ['[', ']'])

            # We are in a section loop
            elif section:

                # Line is a key/value pair
                if '=' in line:
                    k,v = line.split('=', 1)
                    k = self.sanitize(k)
                    v = self.sanitize(v)

                    # replace certain values like ~ -> /home/<user>
                    v = self.replace(v)
                    # TODO Find a solution for this, the replaced variable should not be written back to the file
                    #      Also does this not work for variables set by config.set()

                    # Value is empty, add empty value
                    if not v:
                        option = self.set(section, k, '', comment=comments)
                        comments = []


                    # Value is a list
                    elif v[0] == '[' and v[-1] == ']':
                        v = self.sanitize(v, extra_opts = ['[', ']'])

                        # Value contains a comma. read all values in a list
                        if ',' in v:
                            v_list = self.sanitize_list(v.split(','))
                            option = self.set(section, k, v_list, comment=comments)
                            comments = []


                        # Value doesn't contain comma so could be a list with a single item or an empty list
                        else:
                            if v:
                                option = self.set(section, k, v, comment=comments)
                            else:
                                option = self.set(section, k, [], comment=comments)
                            comments = []

                    # Value is a simple key, value pair
                    else:
                        option = self.set(section, k, v, comment=comments)
                        comments = []

        return self.config


    def set(self, section, k, v, comment=[]):
        """ Create a config_option() instance and fill it with data """
        v = self.convert_numbers(v)
        # If option already exist, change it
        for option in self.get_options():
            if option.get_section() == section:
                if option.get_key() == k:
                    option.set_comment(comment)
                    option.set_value(v)
                    return option
        # If option does not exist, create it
        option = Config_Option(key=k, value=v, section=section, comment=comment)
        self.set_option(option)
        return option


    def get(self, section, key):
        """ Get a value from list of config_option() instances in self.config by section and key """
        for option in self.get_options():
            if option.get_section() == section:
                if option.get_key() == key:
                    return option.get_value()
        if not self.quiet:
            print('Couldn\'t find value for key in section {0} : {1}'.format(section, key))
        return False


    def test_file(self):
        """ Test if file exists """
        try:
            with open(self.config_file_path) as f: pass
            return True
        except IOError as e:
            return False


    def ensure_dir(self, dirname):
        if not os.path.exists(dirname):
            os.makedirs(dirname)


    def write_to_file(self, data=False, remove=False):
        """ Write a string to a file, remove file if it exists by giving remove=False """
        if not self.get_config_path():
            return False

        self.ensure_dir(os.path.dirname(self.get_config_path()))

        if remove == True:
            try:
                FILE = open(self.config_file_path, 'w')
                FILE.close()
                return True
            except:
                if not self.quiet:
                    print('Failed to remove file')
                return False

        else:
            try:
                FILE = open(self.config_file_path, 'a')
                FILE.write(data + '\n')
                FILE.close()
                return True
            except:
                if not self.quiet:
                    print('Failed to write to file')
                pass
        return False


    def write(self):
        """ Write the config to disk """

        self.write_to_file(remove=True)
        section = False
        first = True

        for option in self.get_options():
            current_section = option.get_section()

            if not current_section == section:
                # Only put newline above section header if it is not the first one
                if first:
                    self.write_to_file('[{0}]'.format(current_section))
                    first = False
                else:
                    self.write_to_file('\n[{0}]'.format(current_section))
                section = current_section

            comment = option.get_comment()
            for c in comment:
                self.write_to_file('# {0}'.format(c))

            value = option.get_value()
            if type(value) == list:
                value = '[{0}]'.format(','.join(value))

            self.write_to_file('{0} = {1}'.format(option.get_key(),value))
        if not self.quiet:
            print('File written to: {0}'.format(self.config_file_path))


    def get_file(self):
        """ Get contents of a file and put every line in a list"""
        contents = []
        try:
            f = open(self.config_file_path, 'r')
        except IOError as e:
            if not self.quiet:
                print('No config file found at: {0}'.format(self.config_file_path))
            return False

        for line in f:
            if line:
                contents.append(self.sanitize(line))
        f.close()

        if contents:
            return contents
        return False


    def sanitize(self, data, extra_opts = []):
        """ Clean variable from newlines, leading/trailing spaces and other stuff """
        sanitize_list = [' ', '\'', '\"', '\n'] + extra_opts
        for sanitize in sanitize_list:
            data = data.strip(sanitize)
        return data


    def sanitize_list(self, data):
        """ Clean list indices from newlines, leading/trailing spaces and other stuff """
        output = []
        for x in data:
            x = x.strip()
            x = x.strip('\'')
            x = x.strip('\"')
            x = x.strip('\n')
            x = x.strip('[')
            x = x.strip(']')
            output.append(x)
        data = output[:]
        return data


    def replace(self, data):
        """ Replace characters or strings in a string with something else """
        replace_list = {'~' : os.getenv("HOME"), '<HOSTNAME>' : socket.gethostname()}
        for k,v in replace_list.items():
            data = data.replace(k, v)
        return data


    def parse(self):
        # Parse the config file
        if self.parse_file(self.config_file_path):
            return True
        return False



class Data(object):
    def __init__(self):
        # TODO: create a method to create a filename with date_increasing number
        self.write_path = '/home/eco/usb/data.txt'
        self.channel = False
        self.data = False
        self.loff_p = True
        self.loff_n = True
        #self.timestamp = datetime.datetime.now().strftime("%H:%M:%S.%f")
        self.timestamp = datetime.datetime.today()


    def set_channel(self, channel): self.channel = channel
    def set_data(self, data): self.data = data
    def set_loff_n(self, state): self.loff_n = state
    def set_loff_p(self, state): self.loff_p = state
    def get_channel(self): return self.channel
    def get_data(self): return self.data
    def get_timestamp(self): return self.timestamp
    def get_loff_p(self): return self.loff_p
    def get_loff_n(self): return self.loff_n


    def create_file(self):
        """ Create a file if it doesn't exist """
        try:
            with open(self.write_path) as f: pass
        except IOError as e:
            try:
                FILE = open(self.write_path, 'w')
                FILE.close()
            except IOError as e:
                log.error('WARNING ... Couldn\'t create file \'%s\''%self.write_path)
                return False
        return True


    def write(self):
        """ Write data to file """
        if self.create_file():
            try:
                FILE = open(self.write_path, 'a')
                FILE.write(self.data)
                FILE.close()
            except:
                log.error('Failed to write to file')


    def display(self):
        log.info("{0} {1} {2}".format(self.get_timestamp(), self.get_channel(), self.get_data()))



class DataList(object):
    def __init__(self):
        self.data = []


    def get_timestamp_list(self): return self.data
    def add_data(self, data): self.data.append(data)


    def get_data_list(self, channel):
        return_list = []
        for data in self.data:
            if int(data.get_channel()) == int(channel):
                return_list.append(data.get_data())
        return return_list


    def get_timestamp_list(self, channel):
        return_list = []
        for data in self.data:
            if int(data.get_channel()) == int(channel):
                return_list.append(data.get_timestamp())
        return return_list



class Socket(object):
    def __init__(self, host, port):
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            log.info('Client socket created')
        except socket.error:
            log.error('Failed to create client socket')
            sys.exit()
        #self.socket = socket.socket()
        #self.socket.settimeout(20)
        try:
            self.socket.connect((host, port))
            log.info('Connected to server')
        except socket.error:
            log.error('Failed to connect to server')
            sys.exit()


    def send(self, data, prefix=False):
        # TODO check if connection is still alive
        if prefix:
            data = str(len(data)).rjust(3, '0') + data

        data_bytes = data.encode()

        try:
            self.socket.sendall(data_bytes)
            log.info('>>> {0}'.format(data))
            return True
        except:
            log.error('Failed to send data')
            return False


    def receive(self, bits):
        # TODO check if connection is still alive
        try:
            data = self.socket.recv(int(bits)).decode('utf-8')
            return self.sanitize(data)
        except:
            log.error('Failed to receive data')
        return False


    def sanitize(self, data):
        data = data.strip('\n')
        return data



class PlotThread(StoppableThread):
    def __init__(self):
        StoppableThread.__init__(self)


    def setup(self):
        pass


    def plot(self):
        pass


    def animate(self, i):
        self.ax1.clear()
        self.ax1.plot(self.datalist.get_channel(1))


    def plot(self):
        import matplotlib.pyplot as plt
        import matplotlib.animation as animation
        import matplotlib.dates as dates

        lines = []
        for i in range(1,9):
            d = self.datalist.get_timestamp_list(i)
            d = dates.date2num(d)
            line = plt.plot(d, self.datalist.get_data_list(i))
            #line = plt.plot(self.datalist.get_data_list(i))
            #line = plt.plot(self.datalist.get_data_list(i), self.datalist.get_timestamp_list(i))
            plt.setp(line, label='Channel' + str(i))
            lines.append(line)
        self.setup_plot()
        plt.show()
        return plt


    def run(self):
        print('lkjj')
        self.plot()



class EEG(object):
    def get_file(self, filename):
        """ Get contents of a file and put every line in a list"""
        contents = []
        try:
            f = open(filename, 'r')
        except IOError as e:
            log.error('No config file found at: {0}'.format(filename))
            return False

        for line in f:
            if line:
                contents.append(line)
        f.close()

        if contents:
            return contents
        return False


    def setup_plot(self):
        plt.title('Data for world domination!')
        plt.ylabel('Volts')
        plt.xlabel('Time')
        plt.gcf().autofmt_xdate()   # Rotates/aligns the labels
        plt.legend()
        plt.show()


    def setup_plot_bak(self):
        #plt.title('Data for world domination!')
        #plt.ylabel('freq')
        #plt.xlabel('time')
        #plt.legend()

        style.use('fivethirtyeight')
        self.fig = plt.figure()
        self.ax1 = self.fig.add_subplot(1,1,1)
        ani = animation.FuncAnimation(self.fig, self.animate, interval=1000)
        plt.show()


    def start_threads(self):
        self.running_threads = []
        self.running_threads.append(PlotThread().start())


    def stop_threads(self):
        for thread in self.running_threads:
            thread.stop()


    def animate(self, i):
        self.ax1.clear()
        self.ax1.plot(self.datalist.get_channel(1))


    def plot(self):
        import matplotlib.pyplot as plt
        import matplotlib.animation as animation
        import matplotlib.dates as dates

        lines = []
        for i in range(1,9):
            d = self.datalist.get_timestamp_list(i)
            d = dates.date2num(d)
            line = plt.plot(d, self.datalist.get_data_list(i))
            #line = plt.plot(self.datalist.get_data_list(i))
            #line = plt.plot(self.datalist.get_data_list(i), self.datalist.get_timestamp_list(i))
            plt.setp(line, label='Channel' + str(i))
            lines.append(line)
        self.setup_plot()
        plt.show()
        return plt


    def get_data(self, socket):
        # Receive length of data first, then get the full frame 
        start_time = self.get_timestamp()
        while True:
            length = socket.receive(config.get('general', 'length-size'))
            if length:
                data = socket.receive(length)
                if data:
                    #log.info('<<< {0}{1}'.format(length,data))
                    if data == "DONE":
                        log.info('Finished transmission')
                        return True
                    self.add_data(data)
            else:
                break

            if start_time + int(config.get('general', 'run-time')) <= self.get_timestamp():
                log.info('Run time reached')
                self.socket.send('STOP', prefix=True)
                return True


        log.error('An error occured while transfer')
        return False


    def get_timestamp(self):
        return int(strftime("%d%H%M%S"))


    def add_data(self, rd):
        # Create data objects and add to self.datalist object
        rd = rd.split(',')

        channel = 0
        for index in range(config.get('general', 'length-size'), len(rd)):
            # TODO find the status bit for loff-n and loff-p
            #log.info(' '.join(rd))
            for x in rd:
                if len(rd) > 9000000 or len(rd) < -9000000:
                    log.red('High value: {0}'.format(rd))
            channel += 1
            data = Data()
            data.set_channel(channel)
            data.set_data(rd[index])
            #data.display()
            self.datalist.add_data(data)


    def noise_check(self, socket):
        log.info("Doing noise check")
        socket.send('NOISECHECK', prefix=True)
        if not self.get_data(socket):
            log.error("Failed to get some results")
            return False
        return True


    def ch1(self, socket):
        log.info("Doing noise check")
        socket.send('CHNSET,1,1', prefix=True)
        socket.send('CHNSET,2,0', prefix=True)
        socket.send('CHNSET,3,1', prefix=True)
        socket.send('CHNSET,4,0', prefix=True)
        socket.send('CHNSET,5,0', prefix=True)
        socket.send('CHNSET,6,0', prefix=True)
        socket.send('CHNSET,7,0', prefix=True)
        socket.send('CHNSET,8,0', prefix=True)
        if not self.get_data(socket):
            log.error("Failed to get some results")
            return False
        return True


    def test_signal(self, socket):
        log.info("Starting test signal")
        socket.send('TESTSIGNAL', prefix=True)
        if not self.get_data(socket):
            log.error("Failed to get some results")
            return False
        return True


    def usage(self):
        print("PYEEG")
        print("OPTIONS:")
        print("  --noise-check")
        print("  --test-signal")
        print("  --shutdown")


    def set_config_defaults(self):
        config.set('server', 'address', 'alarmpi')
        config.set('server', 'port', '8888')
        config.set('general', 'length-size', '3')
        config.set('general', 'run-time', '60')


    def change_config_value(self, var, section, key):
        var_split = var.split('=')
        if len(var_split) == 2:
            config.set(section, key, var_split[1])


    def handle_arg(self):
        if len(sys.argv) < 2 or "--help" in sys.argv:
            return self.usage()

        # Setting config values
        for arg in sys.argv:
            if '--run-time=' in arg:
                self.change_config_value(arg, 'general', 'run-time')

            elif '--server-address=' in arg:
                self.change_config_value(arg, 'server', 'address')

            elif '--server-port=' in arg:
                self.change_config_value(arg, 'server', 'port')

        # Create socket
        self.socket = Socket(config.get('server', 'address'), config.get('server', 'port'))

        # Commands
        for arg in sys.argv:
            if "--noise-check" in arg:
                self.noise_check(self.socket)

            elif "--test-signal" in arg:
                self.test_signal(self.socket)

            elif "--shutdown" in arg:
                self.socket.send('SHUTDOWN', prefix=True)

            elif "--ch1" in arg:
                self.ch1(self.socket)

            if "--plot" in arg:
                self.plot()

        return False


    def run(self):
        self.start_threads()
        self.set_config_defaults()
        self.datalist = DataList()
        # Should go in a thread
        #self.setup_plot()

        self.handle_arg()

        #self.plot()
        # NOTE Live updating plot



if __name__ == "__main__":
    config = Config()
    log = Log()
    log.color('>>>', 'green')
    log.color('<<<', 'blue')
    app = EEG()
    app.run()
